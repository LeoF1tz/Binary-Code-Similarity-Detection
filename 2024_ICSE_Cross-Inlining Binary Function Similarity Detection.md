| **Title** | Cross-Inlining Binary Function Similarity Detection  |
|----------|-------------------------------------------------------------------------------------|
| **Author** | Ang jia |
| **Institution** | Xi'an Jiao Tong University  |
| **Venue** | ICSE |
| **Year** | 2024 |

# ABSTRACT
- 研究背景
  - 传统方法通常假设**查询函数和目标函数具有相同的语义**，即它们是**完整匹配的**。然而，实际应用中经常会出现**函数内联**（inlining）的情况，即一个函数的内容被嵌入到另一个函数中，
- 不同的内联方式
  - 作者构建了一个包含 216 种组合的跨内联数据集，基于此发现了**三种内联**方式，并且现有方法应对这三种方式的性能并不好
- CI-Detector 模型
  - 1. 使用**带属性的控制流程图**（ACFG）表示二进制函数语义
  - 2. 使用图神经网络（GNN）将二进制函数转换为向量
  - 3. **根据三种不同的内联模式分别训练模型**，并通过这些模型的相似性结果**进行聚合**，生成最终的相似度判定
- 结果
  - 81% 的精度和 97% 的召回率，超过所有最先进的模型


# Conclusion
- 提出 `CI-Detector` 针对于跨内联匹配
  - 1. 使用 `ACFG` 表示二进制函数语义
  - 2. 使用 `GNN` 将二进制函数转换为嵌入向量
  - 3. 总结出三种跨内联方式，并针对这三种跨内联方式分别训练子模型
  - 4. 输入到子模型中得到相应的相似性评分，最后聚合，得到最终的相似性得分


# 1. INTRODUCTION
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img.png>)
- 1. 现有方法的局限性
  - 现有方法通常假设目标函数与查询函数具有相同语义，但**函数内联会改变语义结构**
  - 函数内联**普遍存在**，但是当前**极少**有研究专门针对内联
    - i.e., (a) 中 `do_free_upto` 是漏洞函数，它被内联到 (b) `CMS_final` 和 (c) `CMS_decrypt` 中（都以 CFG 形式表示）
    - 但是由于现有的方法针对的是语义匹配，而内联改变了这种语义，所以 `do_free_upto` 虽然是 `CMS_final` 和 `CMS_decrypt` 的一部分，但是仍然相似度很低
- 2. 函数内联的挑战
  - 1. 语义模糊
    - 当内联发生时，多个函数的语义相混合，二进制函数的语义更加模糊
  - 2. 多样的内联上下文
    - i.e., `A` 函数被内联到 `B, C, D` 函数中，这就会导致出三种截然不同的上下文组合
  - 3. 多样的内联模式
    - 漏洞函数不仅会被内联到其他函数，它可能也会主动将其他函数内联到自身
- 3. 提出的方法
  - 1. 语义模糊
    - 将操作吗和 CFG 结合，形成 ACFG 表达函数语义
  - 2. 多样的内联上下文
    - 图神经网络识别相似性
  - 3. 多样的内联模式
    - 总结出三种内联模式，并分别训练模型以计算跨内联相似性，最后聚合这些模型结果以获得相似性
- 4. 实验结果
  - AUC = 90.62%


# 2. BRACKGROUND
## 2.1. Binary Function Similarity Detection
- 跨内联相似性检测
  - `Bingo` 和 `Asm2Vec` 尝试使用**手动规则**解决部分内联问题，但是无法适应多样的内联方式


## 2.2. Function Inlining
- 函数内联的定义
  - 函数内联是一种优化技术，其基本原理是**用函数体直接替换函数调用**，这样减少了调用开销
- 性能和代码体积的权衡
  - 内联会导致体积增加，因为每次调用都会被替换成完成的函数代码，因此，编译器会在不超过给定体积的情况下，对高效调用点进行优先内联
- 内联操作流程
  - 计算参数，将它们存储在对应函数参数的变量中，然后将函数的主体插入到调用点


## 2.3. Cross-Inlining Binary Similarity Detection
- 1. `Bingo` 和 `Asm2Vec`
  - 方法
    - 总结调用这内联被调用者的模式来**模拟实际内联后的代码**
  - 缺点
    - 需要查询函数和目标函数在**函数调用图**中**具有相同的上下文**，这样就无法应对多样的内联方式
- 2. Jia
  - 指出内联对相似性的影响，准确率下降 30-40%
  - 提出 `O2NMatcher` 内联模拟策略
    - 方法
      - 它将多个源函数作为内联二进制函数的匹配目标
    - 缺点
      - 依赖源代码的上下文用于判断相似性
- 3. 本文的贡献
  - 跨内联相似性检测方法，**不依赖查询函数和目标函数的上下文**
  - 引入**两种额外**的内联模式


# 3. EMPIRICAL STUDY
## 3.1. Problem Definition
- 问题定义
  - 给定一个不含内联的查询函数 $q$ 和一个含有内联的目标函数 $t$，判断 $q$ 是否被内联到 $t$ 中
- 条件设定
  - $q$ 和 $t$ 在同架构、同优化等级、同编译器下


## 3.2. Cross-inlining Dataset Construction
- 1. 数据集构建
  - `Data-Inlining` 和 `Data-NoInlining`，即使用内联和不使用内联（`fno-inline` 关闭函数内联）
    - `fno-inline` 无法阻止用户强制内联，如（`always_inline`），需后续操作将含有内联的函数剔除
- 2. 二进制到源代码的函数映射
  - 提取 `.debug_line` 信息，构建二进制代码和源代码的**函数**映射关系
    - 地址到行的映射 >> 地址到二进制函数，行到源函数 >> 二进制函数和源代码对齐
  - 通过映射的函数数量识别包含内联的二进制函数
    - 如果一个二进制函数映射到多个源函数，则视为内联函数
- 3. 跨内联函数对的构建
  - 图解
    - (a) 的 `CMS_decrypt` 包含了 (b) 中的三个源函数，即 `CMS_decrypt`, `do_free_upto` 和 `check_content`，这三个函数与 (c) 中的一一对应
    - (a) 取自内联函数集，(c) 取自不使用内联的函数集
  - 识别桥接函数，建立跨内联函数对
    - 将 (a) 中的 `CMS_decrypt` 和 (c) 中的 `do_free_upto` 建立函数映射关系
  - 目的
    - 观察到在内联和非内联条件下相同函数的结构和特征变化，使得模型可以**学习到内联对函数表示的具体影响**


## 3.3. Cross-Inlining Patterns Analysis
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-1.png>)
1. 三种跨内联模式（基于函数调用图的位置）
  - 虚线线头表示二进制代码到源代码的映射，实线箭头表示源函数间的调用关系
  - 左侧 `SF` 为二进制函数，右侧 `SF` 为内联函数，中间为具体的被内联函数
  - 1. 叶节点内联 (a)
    - 特征
      - 被内联函数没有调用其他函数
      - 内联后函数结构被保留的**较为完整**
    - i.e.,
      - `B` 为被内联函数，`B` 没有调用其他函数
  - 2. 根节点内联
    - 特征
      - 被内联函数调用了其他函数
      - 内联会使得**它调用的函数也会被内联**，以桥接函数为起点，**被分割成很多片段**
    - i.e., 
      - `A` 为被内联函数，它调用了 `B`
      - 不仅 `A` 会被内联，`B` 也会被作为内联的一部分，且仍以 `A` 作为内联部分的开头，但是，`A` 的内容会被切分
  - 3. 内部节点内联
    - 特征
      - 桥接函数位于调用链的中间，既被其他函数调用，也调用其他函数
      - 桥接函数在内联后，不仅自身被嵌入到调用它的二进制函数中，还会内联其他调用的函数内容
      - 导致桥接函数的内容分散分布在多个内联函数中，形成了复杂的层级内联结构
    - i.e.,
      - `A` 调用 `B`, `B` 调用 `C`
      - `B` 为桥接函数，在被内联后，其函数内容被打乱分布
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-2.png>)
2. 图表示内联函数的数量随着优化等级的提升显著增加
   - Equal 即不使用内联的函数，显著下降
   - 其余三种曲线分别代表三种内联模式，显著增加
3. 不同编译器的区别
   - `GCC` 随着优化等级的增加，内联程度显著增加
   - `CLang` 中 `O0, O1` 提升不明显是因为 `always inliner`


## 3.4. Cross-inlining Matching Evaluation
1. 叶节点内联
   - 现有模型效果较差，因为这种方式会导致桥接函数在内联后，只占内联函数的一小部分
2. 根节点内联
   - `GMN` 和 `Gemini` 表现较好
   - 这种内联方式的桥接函数通常是小型函数，且在内联后，仍在内联函数中起主要作用
3. 内部节点内联
   - 桥接函数的内容被分散在多个内联部分中，检测能力显著下降
4. 总结，现有模型会不同程度的收到内联的影响，导致性能下降


# 4. METHOD
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-3.png>)
- CI-Detector 的流程
1. 提取 ACFG
2. 针对三种内联模式分别训练三种模型
3. 使用 2 中的模型计算相似性，最后聚合成为最终的相似度


## 4.1. ACFG Construction
1. 为什么选择 `ACFG`
   - 1. `CFG` 的表示方式很稳定（`CFG` 方法在其他 BCSD 方法中被广泛使用）
   - 2. `CFG` 联合 `opcode` （操作码）形成 `ACFG`
2. 指令的组合形式为 `操作码+操作数`，为什么选用 `操作码` 作为 `ACFG` 的一部分，而不是 `操作数`
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-4.png>)
   - 操作码更加稳定
     - (a) 是 `do_free_upto` 函数的 CFG，(c) 是 `CMS_final` 的 CFG，其将 `do_free_upto` 函数内联为自身的一部分
     - 可以看到操作码（红色框）表示**指令要执行什么操作**，在内联后，具有相似性，它们仍然共享一些重要的操作码，i.e., `mov`, `test`, `je`
     - 而操作数（绿色框）表示**指令要操作的数据对象**，不那么具有相似性，甚至是随意性
       - 原因是桥接函数在被内联进函数后，两者具有**不同的函数上下文**，进而导致**函数地址发生变化**，同时，**某些寄存器在内联函数中已经被使用**


## 4.2. Model Training
1. 为什么训练三种不一样的子模型
  - 三个内联**方式存在差异**，分别训练模型，可以更好的捕捉各自的特征
2. 区别于传统的训练对生成
  - 1. 传统方式
    - 具有相同函数名称为正样本对，不同名称则为负样本对
  - 2. 区别原因
    - 因为函数内联存在，不能以函数名称作为区分正负样本的依据
3. **基于跨内联**的训练对生成
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-5.png>)
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-6.png>)
- 目的
  - 识别在**内联过程中**，桥接函数内容**被嵌入到另一个函数**中**带来的相似性变化**
- 方法
  - 1. 使用**源桥接函数**作为**关键字**构建**字典**
  - 2. 子键为与**自身等价的函数**，以及**内联函数**
  - 3. 从两个自键中各随机选择一个，构成**正样本**
  - 4. 从 `equal` 中随机选择一个，和**不属于**对应 `cross-inling` 子键的函数中选择一个，构成**负样本**
- i.e.,
  1.  图1 中包含了两个内联对
      - `do_free_upto` 和 `CMS_final`
      - `do_free_upto` 和 `CMS_decrypt`
  2. 桥接函数作为**主键**，即 `do_free_upto`
  3. `equal` （与主键**等价的函数**）和 `cross-inling`（内联函数）为子键
  4. 形如：
  ```{
    "桥接函数名称": {
        "equal": [不含内联的二进制函数列表],
        "cross-inlining": [包含该桥接函数的含内联二进制函数列表]
    },
    ...
    }
  ```
4. ACFG 嵌入
   1. 将 ACFG 中每个节点转换成向量
      - 使用**词袋**模型处理操作码
        - 词袋模型通过统计每个次**在文本中出现的频率**来表示内容的特征
      - i.e.
        - `[push, push, push, mov, test, je]` 即频率可表示为 `{"push":3, "mov":1, "test":1, "je":1}`
        - 据此构建词汇表 '[push, mov, test, je]`
        - 得到向量表示 `[3, 1, 1, 1]`
   2. 编码器映射到向量空间中
   3. 多个传播层使得节点聚合**相邻节点的信息**
   4. 聚合器聚合图中**所有节点的表示**，生成整个图的表示
5. 模型训练
   1. 基于每个跨内联函数对 $(G_1, G_2)$ 生成其 ACFG 嵌入向量
   2. 使用欧几里得相似度计算他们的相似性
   3. 使用 $Loss=max\{0, \gamma-t(1-d(G1,G1))\}$ 计算损失函数和更新


## 4.3. Model Testing
- 1. 三个模型生成相似度
  - 对每一个输入对，都分别输入进三个模型中
- 2. 使用最大相似度
  - 选择三个模型的最大输出最为最后的相似性得分
- 3. 相似度阈值
  - `>0.55` 相似，否则不相似


# 5. EXPERIMENTS
## 5.2. RQ1：Effectiveness of CI-Detector
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-7.png>)
1. 总结
   - `CI-Detector` 在检测跨内联对时可以达到 81% 的精确率和 97% 的召回率
2. 假阴性
   - 定义
     - 实际为正，但 `CI-Detector` 判断为负
   - 原因
     - 某些正样本对的函数大小差异过大
       - 体现在**指令数**和**基本块数**
3. 假阳性
   - 定义
     - 实际为负，但 `CI-Detector` 判断为正
   - 原因
     - 某些单一功能的小函数被误认为是跨内联对


## 5.3. RQ2: Compared with Existing Works
1. 总结
   - `CI-Detector` 在所有指标上都优于现有方法
2. 通过针对不同的内联模式分别训练模型，`CI-Detector` 能够在检测各类跨内联对时达到高覆盖率


## 5.4. RQ3: Contribution of Each Model
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-8.png>)
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-9.png>)
1. 单一模型中主要差异在 `Leaf` 和 `Internal`
   - 这表明单一模型的学习**不具有很好的泛化能力** 
   - `Root` 类型更容易被学习
2. 混合模型的主要差异在 `Recall`
   - 这表明三种类型的**内联存在显著差异**，混合训练会增加模型的学习难度
3. 各模型学习差异
   - 不同内联模型可以相互补充，有助于检查出其他模型无法单独检测到的正样本对
   - i.e., （图解）
     - `Leaf pairs` 中的 `RI` 橙色柱状表示 `RI` 模型可以检测出，但是 `LI` 模型未检测出的正样本对


## 5.5. RQ4: Efficiency of CI-Detector
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-10.png>)
![alt text](<images/Cross-Inlining Binary Function Similarity Detection/img-11.png>)
1. 训练时间分析
   - 不同子模型的训练时间不同
     - `RI` = 20h, `LI` = 37h, `II` = 48h
   - `CI-Detector` 只需要被训练一次
2. 测试时间分析
   - `CI-Detector` 每对平均耗时为 **0.013s**，明显高于其他方法，但可以接受


# 6. THREATS TO VALIDITY
1. 内部有效性威胁
   - 反汇编的质量直接影响模型的输入质量，进而会对模型的性能产生影响
2. 外部有效性威胁
   - 本文的编译选项是有限的，可能会有其他新的编译选项对论文结果产生影响
3. 构建有效性威胁
   - 第三方软件的数据集标记也会对输入和训练产生影响


# Related Knowledge
## 1. 函数内联改变语义结构
- 函数内联会将**一个函数的内容直接嵌入到调用它的代码块中**，使得原始的函数结构被破坏，即语义结构被改变

## 2. Equal 不作为训练对，那对不使用内联的情况，性能还会好吗

## 3. 词袋模型
- 定义
  - **忽略顺序**，仅统计每个词或元素在文本或序列中**出现的频率**，以此来表示内容的特征
- 特点
  - 1. 无序性
    - 词袋模型不关心操作码出现的顺序，只关注频率。例如，`push, mov, test` 和 `test, push, mov` 生成的向量是**相同**的，因为它们出现的**操作码和频率一致**
  - 2. 新增词汇的扩展性
    - 只需要为每个向量增加对应位置
- i.e.,
  - 词汇表
    -  `["push", "mov", "test", "je", "add", "sub"]`
  -  操作码序列: `push, push, mov, add, add, sub`
     -  1. **统计频率**：
         - `push` 出现 2 次
         - `mov` 出现 1 次
         - `test` 没有出现
         - `je` 没有出现
         - `add` 出现 2 次
         - `sub` 出现 1 次
     - 2. **向量表示**：
         - `[2, 1, 0, 0, 2, 1]`